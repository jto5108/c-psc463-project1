Time-Series Clustering and Segment Analysis on PulseDB Using Divide-and-Conquer Algorithms

 

Problem Description

Design a system that performs unsupervised clustering of time-series segments extracted from PulseDB, using divide-and-conquer strategies and algorithmic reasoning. The goal is to group similar physiological signal segments (e.g., ECG, PPG, ABP) and analyze their internal structure using closest pair algorithms and maximum subarray analysis.

This project emphasizes how algorithmic design — rather than ML heuristics — can drive meaningful segmentation and interpretation of biomedical time-series data.

 

Key components and algorithms

1. Divide-and-Conquer Clustering of Time Series Segments
Use PulseDB’s 10-second segments of ECG/PPG/ABP signals.
Apply recursive partitioning based on signal similarity (e.g., correlation, DTW distance).
Each recursive split forms a candidate cluster of time series segments.
2. Closest Pair of Time Series Within Clusters
Within each cluster, identify the most similar pair of time series segments using a closest-pair algorithm.
Use this to:
Validate cluster cohesion.
Select representative pairs for further analysis.
3. Maximum Subarray Analysis (Kadane’s Algorithm)
Apply Kadane’s algorithm to each individual time series segment to identify the most active or anomalous interval.
Use this to reason about why certain segments belong together in a cluster (e.g., shared peak activity).
Dataset: PulseDB
Use 1000 segments where each segment have 10 seconds records 
Signals ABP (Arterial Blood Pressure)
Available via GitHubLinks to an external site. and Kaggle 
 

 

Outline of the Project (These steps provide the overall expected works. You do not need to follow steps in the same way)

Input
A dataset of univariate time-series segments from PulseDB. (1000 time series)

Step 1: Cluster Time-Series Segments Using Divide-and-Conquer
Apply a divide-and-conquer clustering strategy to group similar time-series segments.
Use recursive partitioning based on similarity metrics.
Each recursive split produces a candidate cluster of time-series segments.
This step simulates a top-down clustering approach without relying on ML libraries.
Step 2: Identify Closest Pair of Time Series Within Each Cluster
For each cluster, apply a closest pair of time series algorithm:
Compute pairwise similarity (e.g., DTW distance).
Identify the most similar pair to assess cluster cohesion.
This helps validate the clustering and select representative examples.
Step 3: Apply Maximum Subarray (Kadane’s Algorithm) to Each Time Series
For each time-series segment, apply Kadane’s Algorithm to find the interval of maximum cumulative change.
Use this to:
Extract features for clustering.
Reason about why certain segments belong together (e.g., shared peak activity).
Highlight significant physiological events (e.g., stress, arrhythmia).
Step 4: Generate Reports and Visualizations
Create visual summaries of
Cluster structures and representative time series.
Closest pairs and their similarity scores.
Maximum subarray intervals for each segment.
Optionally, include performance metrics (e.g., clustering time, similarity computation cost).
Output
Clusters of similar time-series segments.
Representative pairs and reasoning based on signal dynamics.
Visual and textual reports summarizing the clustering and analysis.
 

Deliverables

Code submission
The codebase should be well-organized, with a modular structure that clearly separates different functionalities. Classes should be designed to handle specific tasks such as data sorting, trend analysis, and anomaly detection.
Ensure that the code is clean, maintainable, and follows best practices for Python programming.
Minimal report requirements
Provide an overview of the project, including the problem being addressed and the goals of the analysis.
Provide the description of the algorithms such as clustering algorithm with divide and conquer, and Kadane's algorithm 
Include a block diagram or flowchart that illustrates the overall structure of the implementation, showing how different components interact.
Provide a brief summary of each developed class, including its purpose and key methods.
Offer clear instructions on how to install a program and use a program.
Include screenshots or examples of code execution to demonstrate the system in action.
Provide the verification for each component algorithm with toy example
Provide the results associated with each step to analyze the 1000 time series
Discuss the findings from the project, including insights gained from the data analysis and any challenges faced during implementation.
Address any limitations of the system and suggest possible areas for improvement.
 

Required Sections in Report 

Description of project
Installation and usage
Structure of Code
Description of algorithms
Verification of the functionality with toy example
Execution results with 1000 time series
Discussion on execution results
Conclusions
Submission guidelines

Your project submission should include a GitHub repository link containing all required deliverables. Ensure the repository is set to public and curated to include all necessary documentation and code files.
Failure to properly set up the repository or provide complete deliverables may affect your evaluation score.
 

Evaluation Criteria

Code (20%)
Organization: The code is well-structured and easy to navigate.
Modularity: The system uses modular classes with clearly defined responsibilities.
Supported Functionalities: The code implements all required fuctionalties
Report (70%)
Completeness and clarity of the project overview and data type-specific considerations.
Quality of the provided diagrams and explanation to show the overall structure of your code
The thoroughness of the class summaries.
Clarity and completeness of the usage instructions provided.
The verification for each component algorithm with toy example
The demonstration of sample scenarios that illustrate common operations, such as analyzing stock prices, detecting anomalies, and generating trend reports.
Insight of the discussion on project findings, limitations, and improvement suggestions.
Quality of editing, structuring, and presenting the report.
GitHub Repository Setting (10%)
Setting to Public: The repository is accessible to reviewers.
Curating the Repository: All relevant project files, including code and documentation, are present and well-organized within the repository.
 
